import { Injectable, Logger } from '@nestjs/common';
import mysql from 'mysql2/promise';
import { GeminiLlmService } from './gemini/gemini-llm.service';
import { createSqlPrompt } from './prompt/sql.prompt';

interface ProductRow {
  title: string;
  sku: string;
  imageUrl: string;
  price: number;
}

@Injectable()
export class ChatboxService {
  private readonly logger = new Logger(ChatboxService.name);

  private promptTemplate;
  private connection: mysql.Connection | null = null;

  constructor(private readonly geminiLlm: GeminiLlmService) {
    this.initDbConnection().catch((err) => {
      this.logger.error(
        'Failed to initialize DB connection on service init',
        err
      );
    });

    this.initPromptTemplate();
  }

  async initDbConnection() {
    try {
      this.connection = await mysql.createConnection({
        host: 'ecommercedb.co5ikwmcma3k.us-east-1.rds.amazonaws.com',
        user: 'admin',
        password: 'Neulanh1',
        database: 'ecommercedb',
        port: 3306,
      });
      this.logger.log('MySQL connected');
    } catch (error) {
      this.logger.error('MySQL connection error:', error);
      this.connection = null;
      throw error;
    }
  }

  async checkConnection(): Promise<boolean> {
    if (!this.connection) return false;
    try {
      await this.connection.query('SELECT 1');
      return true;
    } catch (error) {
      this.logger.warn('MySQL connection check failed:', error);
      return false;
    }
  }

  async initPromptTemplate() {
    const schemaStr = `
Bạn là trợ lý tạo câu SQL để truy vấn dữ liệu sản phẩm và biến thể (variant) theo câu hỏi người dùng.

Database có các bảng:
- products(id, title, description)
- variants(id, productId, sku, price, compare_at_price)
- variant_option_values(id, variantId, optionValueId)
- option_values(id, value, optionId)
- options(id, name, productId)
- images(id, imageUrl, productId, variantId)

Quan hệ:
- products liên kết variants qua products.id = variants.productId
- variants liên kết variant_option_values qua variants.id = variant_option_values.variantId
- variant_option_values liên kết option_values qua variant_option_values.optionValueId = option_values.id
- option_values liên kết options qua option_values.optionId = options.id
- variants liên kết images qua variants.id = images.variantId

Hướng dẫn tạo câu SQL:
- Luôn select các trường:
  products.title AS title,
  variants.sku AS sku,
  images.imageUrl AS imageUrl,
  variants.price AS price
- Tự động xác định các thuộc tính variant được hỏi trong câu hỏi (ví dụ: color, size, store, material, ...)
- Với mỗi thuộc tính variant được hỏi:
  - JOIN các bảng variant_option_values, option_values, options tương ứng với alias theo tên thuộc tính (vd: color_vov, color_option_value, color_option)
  - Thêm điều kiện WHERE tương ứng, ví dụ:
    LOWER(color_option_value.value) LIKE LOWER('%giá trị%')
- Nếu không có thuộc tính variant nào được hỏi, không join thêm các bảng variant_option_values, option_values
- Chỉ trả về câu SQL SELECT hợp lệ, KHÔNG có chú thích hay giải thích
- Sử dụng LOWER(... ) LIKE LOWER(...) để so sánh giá trị

Ví dụ câu hỏi: "cho tôi sản phẩm điện thoại có store 256GB và color đen"

Trả về câu SQL:

-- Phần trả về phải tự động join bảng variant_option_values, option_values, options cho store và color
-- Thêm điều kiện lọc WHERE với store và color tương ứng
    `;
    this.promptTemplate = createSqlPrompt(schemaStr);
    this.logger.log('Prompt template initialized');
  }

  async query(
    question: string
  ): Promise<{ message: string; data: ProductRow[] }> {
    try {
      if (!this.connection) {
        this.logger.warn('No DB connection, reconnecting...');
        await this.initDbConnection();
      } else {
        const isConnected = await this.checkConnection();
        if (!isConnected) {
          this.logger.warn('DB connection lost, reconnecting...');
          await this.initDbConnection();
        }
      }

      // Tạo prompt để Gemini sinh SQL
      const prompt = await this.promptTemplate.format({ input: question });
      this.logger.log(`Prompt sent to Gemini: ${prompt}`);

      const sqlRaw = await this.geminiLlm.invoke(prompt);
      this.logger.log(`SQL generated by Gemini:\n${sqlRaw}`);

      // Loại bỏ markdown code block nếu có
      const cleanedSql = sqlRaw
        .replace(/^```sql\s*/, '')
        .replace(/\s*```$/, '')
        .trim();

      if (!cleanedSql.toLowerCase().startsWith('select')) {
        throw new Error('Chỉ cho phép câu truy vấn SELECT');
      }

      // Thực thi câu SQL
      const [rows] = await this.connection.execute(cleanedSql);

      // Map dữ liệu trả về, thêm các thuộc tính variant nếu có
      const data = (rows as ProductRow[]).map((row) => {
        const base = {
          title: row.title,
          sku: row.sku,
          imageUrl: row.imageUrl,
          price: row.price,
        };
        // Lấy thêm các thuộc tính variant tự động, lọc ra các cột ngoài base fields
        const extraAttrs = Object.keys(row).filter(
          (k) => !['title', 'sku', 'imageUrl', 'price'].includes(k)
        );
        for (const attr of extraAttrs) {
          base[attr] = row[attr];
        }
        return base;
      });

      // Tạo prompt tóm tắt kết quả trả lời người dùng
      const summary =
        data.length === 0
          ? 'Không có sản phẩm nào phù hợp.'
          : `Có ${data.length} sản phẩm, ví dụ: ${data
              .slice(0, 3)
              .map((d) => d.title)
              .join(', ')}`;

      const messagePrompt = `Bạn là trợ lý chatbot bán hàng. 
Dựa trên kết quả tìm kiếm sau đây:\n${summary}
Hãy trả lời người dùng một cách thân thiện, ngắn gọn, và dễ hiểu.`;

      const messageRaw = await this.geminiLlm.invoke(messagePrompt);
      const message = messageRaw.trim();

      return { message, data };
    } catch (error) {
      this.logger.error('Error in query:', error);
      throw error;
    }
  }
}
